/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include "descriptors.h"

#include "atusbprog_proto.h"

#include "spi_0.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

typedef void (*usbRxHandler_t)(uint16_t len);

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_in_msg_t msg;
} usb_tx_t;

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_out_msg_t msg;
} usb_rx_t;

static void atusbprog_setup_tx(uint8_t len_msg);
static void atusbprog_setup_rx(void);
static void writechar(uint8_t c);

// Command Handlers
static void usbRx_VersionReq(uint16_t len);
static void usbRx_LedReq(uint16_t len);
static void usbRx_InitPgmModeReq(uint16_t len);
static void usbRx_DataWrite(uint16_t len);

/* This must be kept up-to-date with aup_msg_type_t. */
SI_SEGMENT_VARIABLE(usbRxHandlers[], const usbRxHandler_t, SI_SEG_CODE) = {
    usbRx_VersionReq,
    usbRx_LedReq,
    usbRx_InitPgmModeReq,
    usbRx_DataWrite,
};

SI_SEGMENT_VARIABLE(numUsbRxHandlers, const size_t, SI_SEG_CODE) =
        sizeof(usbRxHandlers) / sizeof(usbRxHandlers[0]);

SI_SEGMENT_VARIABLE(usb_tx, usb_tx_t, SI_SEG_IDATA);
SI_SEGMENT_VARIABLE(usb_rx, usb_rx_t, SI_SEG_IDATA);

void USBD_EnterHandler(void) {

}

void USBD_ExitHandler(void) {

}

void USBD_ResetCb(void) {

}

static void writechar(uint8_t c) {
    unsigned char sfr_save = SFRPAGE;
    SFRPAGE = 0x20;
    SBUF0 = c;
    while(!SCON0_TI) {
        NOP();
    }
    SCON0_TI = 0;
    SFRPAGE = sfr_save;
}

// TODO: move this
static void atusbprog_setup_rx(void) {

    int8_t status;

    if (USBD_EpIsBusy(EP1OUT)) {
        return;
    }

    writechar('r');
    status = USBD_Read(EP1OUT, (uint8_t *)usb_rx.buf, AUP_MAX_PACKET_SIZE, true);

    if (status != 0) {
        writechar('!');
    }
}

static void atusbprog_setup_tx(uint8_t len_msg) {

    int8_t status;

    if (USBD_EpIsBusy(EP1IN)) {
        return;
    }

    writechar('t');
    status = USBD_Write(EP1IN, (uint8_t *)usb_tx.buf, len_msg + AUP_IN_MSG_HDR_LEN, false);

    if (status != 0) {
        writechar('!');
    }
}

void USBD_SofCb(uint16_t sofNr) {
    UNREFERENCED_ARGUMENT(sofNr);
    atusbprog_setup_rx();
}

USB_Status_TypeDef USBD_SetupCmdCb(
        SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {

    USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

    UNREFERENCED_ARGUMENT(setup);

    return retVal;
}

static void usbRx_VersionReq(uint16_t len) {

    UNREFERENCED_ARGUMENT(len);

    usb_tx.msg.msg_type = AUP_MSG_VERSION_REQ_RSP;
    usb_tx.msg.msg_data.version_rsp.maj = AUP_PROTO_VERSION_MAJ;
    usb_tx.msg.msg_data.version_rsp.min = AUP_PROTO_VERSION_MIN;
    usb_tx.msg.msg_data.version_rsp.rev = AUP_PROTO_VERSION_REV;
    atusbprog_setup_tx(sizeof(aup_in_msg_version_rsp_t));
}

static void usbRx_LedReq(uint16_t len) {

    UNREFERENCED_ARGUMENT(len);

    // todo cleanup
    // need note on inverted LED (i.e. bsp define, etc)

    writechar('u');

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_RED) {
        writechar('1');
        P1_B6 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_RED ? 0 : 1;
    }

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_GRN) {
        writechar('2');
        P1_B4 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_GRN ? 0 : 1;
    }

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_BLU) {
        writechar('3');
        P1_B5 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_BLU ? 0 : 1;
    }
}

static void usbRx_InitPgmModeReq(uint16_t len) {

    UNREFERENCED_ARGUMENT(len);

    writechar('p');

    if (usb_rx.msg.msg_data.pgm_mode_req.chip_id == PGM_MODE_CHIP_ID_RAW_SPI) {

    } else {

    }
}

static void usbRx_DataWrite(uint16_t len) {

    // TODO: just do a spi write
    // TODO: this should be moved out of the USB interrupt

    SI_SEGMENT_VARIABLE(dptr, uint8_t *, SI_SEG_IDATA);

    if (len <= AUP_IN_MSG_HDR_LEN) {
        /* No data to send. */
        return;
    }

    len -= AUP_IN_MSG_HDR_LEN;

    dptr = usb_rx.msg.msg_data.data_write.payload;

    // dummy: lower and  raise AT_OE_N (P1_2)

    P1_B2 = 0;
    // TODO: kick off spi transfer after delay (spare timer?)

    // Fill the fifo
    while (len) {
        SPI0_pollWriteByte(*dptr);
        dptr++;
        len--;
    }

    // Wait for the byte to finish sending
    while (SPI0_isBusy())
    {
    }

    P1_B2 = 1;

}

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
        uint16_t xferred, uint16_t remaining) {

    usbRxHandler_t handler = NULL;
    uint8_t command_id;

    //UNREFERENCED_ARGUMENT(epAddr);
    UNREFERENCED_ARGUMENT(status);
    UNREFERENCED_ARGUMENT(xferred);
    UNREFERENCED_ARGUMENT(remaining);

    /* If this is not an OUT transaction (Host -> UB1), we don't care. */
    if (epAddr != EP1OUT) {
        return 0;
    }

    if  (status != USB_STATUS_OK) {
        writechar('S');
        return 0;
    }

    command_id = usb_rx.msg.msg_type;
    if (command_id < numUsbRxHandlers) {
        handler = usbRxHandlers[command_id];
    }

    // Did we find a handler?
    if (handler != NULL) {
        handler(xferred);
    } else {
        writechar('?');
        // Send a generic command response back indicating an error.
        // TODO
    }

    // Setup the next read.
    atusbprog_setup_rx();

    return 0;
}
