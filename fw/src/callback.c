/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include "descriptors.h"

#include "atusbprog_proto.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

static void atusbprog_setup_tx(uint8_t len_msg);
static void atusbprog_setup_rx(void);
static void writechar(uint8_t c);

void USBD_EnterHandler(void) {

}

void USBD_ExitHandler(void) {

}

void USBD_ResetCb(void) {

}

#if 0
typedef struct frameReptToFw_s {
    uint16_t incr;
} frameReptToFw_t;

typedef struct frameReptToHost_s {
    uint16_t reptNr;
    uint16_t sofNr;
    uint16_t rxNr;
} frameReptToHost_t;

static uint16_t rx_ctr;
static frameReptToFw_t lastRx;
static frameReptToHost_t lastReport;
static uint16_t numRepts;
static unsigned char blink2;
#endif

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_in_msg_t msg;
} usb_tx_t;

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_out_msg_t msg;
} usb_rx_t;

SI_SEGMENT_VARIABLE(usb_tx, usb_tx_t, SI_SEG_IDATA);
SI_SEGMENT_VARIABLE(usb_rx, usb_rx_t, SI_SEG_IDATA);

static void writechar(uint8_t c) {
    unsigned char sfr_save = SFRPAGE;
    SFRPAGE = 0x20;
    SBUF1 = c;
    SFRPAGE = sfr_save;
}

// TODO: move this
static void atusbprog_setup_rx(void) {

    int8_t status;

    if (USBD_EpIsBusy(EP1OUT)) {
        return;
    }

    writechar('r');
    status = USBD_Read(EP1OUT, (uint8_t *)usb_rx.buf, AUP_MAX_PACKET_SIZE, true);

    if (status != 0) {
        writechar('!');
    }
}

static void atusbprog_setup_tx(uint8_t len_msg) {

    int8_t status;

    if (USBD_EpIsBusy(EP1IN)) {
        return;
    }

    writechar('t');
    status = USBD_Write(EP1IN, (uint8_t *)usb_tx.buf, len_msg + AUP_IN_MSG_HDR_LEN, false);

    if (status != 0) {
        writechar('!');
    }
}

void USBD_SofCb(uint16_t sofNr) {

    //int8_t status;

    UNREFERENCED_ARGUMENT(sofNr);

    atusbprog_setup_rx();

#if 0
    lastReport.reptNr = htole16(numRepts);
    lastReport.sofNr = htole16(sofNr);
    lastReport.rxNr = htole16(rx_ctr);

    status = USBD_Write(EP1IN, (uint8_t *)&lastReport, sizeof(lastReport), false);
    if (status == USB_STATUS_OK)
    {
        writechar('W');

        //P1_B4 = blink2;
        blink2 = !blink2;

        numRepts += 1;
    }
#endif
}

USB_Status_TypeDef USBD_SetupCmdCb(
        SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {

    USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

    UNREFERENCED_ARGUMENT(setup);

    return retVal;
}

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
        uint16_t xferred, uint16_t remaining) {

    //uint16_t incr;

    //UNREFERENCED_ARGUMENT(epAddr);
    UNREFERENCED_ARGUMENT(status);
    UNREFERENCED_ARGUMENT(xferred);
    UNREFERENCED_ARGUMENT(remaining);

    /* If this is not an OUT transaction (Host -> UB1), we don't care. */
    if (epAddr != EP1OUT) {
        return 0;
    }

    if  (status != USB_STATUS_OK) {
        writechar('S');
        return 0;
    }

    // Process the read.
    switch (usb_rx.msg.msg_type) {
    case AUP_MSG_VERSION_REQ_RSP:
        usb_tx.msg.msg_type = AUP_MSG_VERSION_REQ_RSP;
        usb_tx.msg.msg_data.version_rsp.maj = AUP_PROTO_VERSION_MAJ;
        usb_tx.msg.msg_data.version_rsp.min = AUP_PROTO_VERSION_MIN;
        usb_tx.msg.msg_data.version_rsp.rev = AUP_PROTO_VERSION_REV;
        atusbprog_setup_tx(sizeof(aup_in_msg_version_rsp_t));
        break;
    case AUP_MSG_LED_REQ:

    	// todo cleanup
    	// need note on inverted LED (i.e. bsp define, etc)

    	writechar('u');

        if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_RED) {
        	writechar('1');
            P1_B6 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_RED ? 0 : 1;
        }

        if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_GRN) {
        	writechar('2');
            P1_B4 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_GRN ? 0 : 1;
        }

        if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_BLU) {
        	writechar('3');
            P1_B5 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_BLU ? 0 : 1;
        }

        break;
    }

    // Setup the next read.
    atusbprog_setup_rx();

    return 0;
}
