/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include "descriptors.h"

#include "atusbprog_proto.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

typedef void (*usbRxHandler_t)(void);

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_in_msg_t msg;
} usb_tx_t;

typedef union {
    uint8_t buf[AUP_MAX_PACKET_SIZE];
    aup_out_msg_t msg;
} usb_rx_t;

static void atusbprog_setup_tx(uint8_t len_msg);
static void atusbprog_setup_rx(void);
static void writechar(uint8_t c);

// Command Handlers
static void usbRx_VersionReq(void);
static void usbRx_LedReq(void);
static void usbRx_InitPgmModeReq(void);

/* This must be kept up-to-date with aup_msg_type_t. */
SI_SEGMENT_VARIABLE(usbRxHandlers[], const usbRxHandler_t, SI_SEG_CODE) = {
    usbRx_VersionReq,
    usbRx_LedReq,
    usbRx_InitPgmModeReq,
};

SI_SEGMENT_VARIABLE(numUsbRxHandlers, const size_t, SI_SEG_CODE) =
        sizeof(usbRxHandlers) / sizeof(usbRxHandlers[0]);

SI_SEGMENT_VARIABLE(usb_tx, usb_tx_t, SI_SEG_IDATA);
SI_SEGMENT_VARIABLE(usb_rx, usb_rx_t, SI_SEG_IDATA);

void USBD_EnterHandler(void) {

}

void USBD_ExitHandler(void) {

}

void USBD_ResetCb(void) {

}

static void writechar(uint8_t c) {
    unsigned char sfr_save = SFRPAGE;
    SFRPAGE = 0x20;
    SBUF0 = c;
    while(!SCON0_TI) {
    	NOP();
    }
    SCON0_TI = 0;
    SFRPAGE = sfr_save;
}

// TODO: move this
static void atusbprog_setup_rx(void) {

    int8_t status;

    if (USBD_EpIsBusy(EP1OUT)) {
        return;
    }

    writechar('r');
    status = USBD_Read(EP1OUT, (uint8_t *)usb_rx.buf, AUP_MAX_PACKET_SIZE, true);

    if (status != 0) {
        writechar('!');
    }
}

static void atusbprog_setup_tx(uint8_t len_msg) {

    int8_t status;

    if (USBD_EpIsBusy(EP1IN)) {
        return;
    }

    writechar('t');
    status = USBD_Write(EP1IN, (uint8_t *)usb_tx.buf, len_msg + AUP_IN_MSG_HDR_LEN, false);

    if (status != 0) {
        writechar('!');
    }
}

void USBD_SofCb(uint16_t sofNr) {

    //int8_t status;

    UNREFERENCED_ARGUMENT(sofNr);

    atusbprog_setup_rx();

#if 0
    lastReport.reptNr = htole16(numRepts);
    lastReport.sofNr = htole16(sofNr);
    lastReport.rxNr = htole16(rx_ctr);

    status = USBD_Write(EP1IN, (uint8_t *)&lastReport, sizeof(lastReport), false);
    if (status == USB_STATUS_OK)
    {
        writechar('W');

        //P1_B4 = blink2;
        blink2 = !blink2;

        numRepts += 1;
    }
#endif
}

USB_Status_TypeDef USBD_SetupCmdCb(
        SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {

    USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

    UNREFERENCED_ARGUMENT(setup);

    return retVal;
}

static void usbRx_VersionReq(void) {
    usb_tx.msg.msg_type = AUP_MSG_VERSION_REQ_RSP;
    usb_tx.msg.msg_data.version_rsp.maj = AUP_PROTO_VERSION_MAJ;
    usb_tx.msg.msg_data.version_rsp.min = AUP_PROTO_VERSION_MIN;
    usb_tx.msg.msg_data.version_rsp.rev = AUP_PROTO_VERSION_REV;
    atusbprog_setup_tx(sizeof(aup_in_msg_version_rsp_t));
}

static void usbRx_LedReq(void) {
	// todo cleanup
	// need note on inverted LED (i.e. bsp define, etc)

	writechar('u');

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_RED) {
    	writechar('1');
        P1_B6 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_RED ? 0 : 1;
    }

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_GRN) {
    	writechar('2');
        P1_B4 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_GRN ? 0 : 1;
    }

    if (usb_rx.msg.msg_data.led_req.led_mask & LED_REQ_MASK_BLU) {
    	writechar('3');
        P1_B5 = usb_rx.msg.msg_data.led_req.led_val & LED_REQ_MASK_BLU ? 0 : 1;
    }
}

static void usbRx_InitPgmModeReq(void) {
	writechar('p');

	if (usb_rx.msg.msg_data.pgm_mode_req.chip_id == PGM_MODE_CHIP_ID_RAW_SPI) {

	} else {

	}
}

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
        uint16_t xferred, uint16_t remaining) {

	usbRxHandler_t handler = NULL;
	uint8_t command_id;

    //UNREFERENCED_ARGUMENT(epAddr);
    UNREFERENCED_ARGUMENT(status);
    UNREFERENCED_ARGUMENT(xferred);
    UNREFERENCED_ARGUMENT(remaining);

    /* If this is not an OUT transaction (Host -> UB1), we don't care. */
    if (epAddr != EP1OUT) {
        return 0;
    }

    if  (status != USB_STATUS_OK) {
        writechar('S');
        return 0;
    }

    command_id = usb_rx.msg.msg_type;
    if (command_id < numUsbRxHandlers) {
    	handler = usbRxHandlers[command_id];
    }

    // Did we find a handler?
    if (handler != NULL) {
    	handler();
    } else {
    	writechar('?');
    	// Send a generic command response back indicating an error.
    	// TODO
    }

    // Setup the next read.
    atusbprog_setup_rx();

    return 0;
}
